p3.
UDP和TCP使用反码来计算它们的检验和。假设你有下面3个8比特字节: 01010011，01100110，01110100。这些8比特字节和的反码是多少? ( 注意到尽管UDP和TCP使用16比特的字来计算检验和，但对于这个问题，你应该考虑8比特和。)写出所有工作过程。UDP为什么要用该和的反码，即为什么不直接使用该和呢?使用该反码方案，接收方如何检测出差错? 1比特的差错将可能检测不出来吗? 2比特的差错呢?

P6.考虑我们改正协议rdl2.1的动机。试说明如图3-57所示的接收方与如图3-11所示的发送方运行时，接收方可能会引起发送方和接收方进人死锁状态，即双方都在等待不可能发生的事件。

